%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{Event\_Log\_Analyzer}
\date{Dec 01, 2021}
\release{1.0.0}
\author{Bernhard Zosel}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
Event Log Analyzer for importing event logs and classifying them according to constraint patterns.


\chapter{event\_log\_analyzer package}
\label{\detokenize{event_log_analyzer:event-log-analyzer-package}}\label{\detokenize{event_log_analyzer::doc}}\label{\detokenize{event_log_analyzer::doc}}

\section{event\_log\_analyzer.importer module}
\label{\detokenize{event_log_analyzer:module-event_log_analyzer.importer}}\label{\detokenize{event_log_analyzer:event-log-analyzer-importer-module}}\index{module@\spxentry{module}!event\_log\_analyzer.importer@\spxentry{event\_log\_analyzer.importer}}\index{event\_log\_analyzer.importer@\spxentry{event\_log\_analyzer.importer}!module@\spxentry{module}}
\sphinxAtStartPar
This module contains thr functionality to import new event logs.
\index{import\_csv\_file() (in module event\_log\_analyzer.importer)@\spxentry{import\_csv\_file()}\spxextra{in module event\_log\_analyzer.importer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.importer.import_csv_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{event\_log\_analyzer.importer.}}\sphinxbfcode{\sphinxupquote{import\_csv\_file}}}{\emph{\DUrole{n}{config}}}{}
\sphinxAtStartPar
Import the event log from the file format into a pandas dataframe
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{config\_file}} \textendash{} the path to a JSON configuration file

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the pandas dataframe without any modification (only the string timestamps are converted to real timestamps)

\item[{Return type}] \leavevmode
\sphinxAtStartPar
raw\_dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{import\_event\_log() (in module event\_log\_analyzer.importer)@\spxentry{import\_event\_log()}\spxextra{in module event\_log\_analyzer.importer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.importer.import_event_log}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{event\_log\_analyzer.importer.}}\sphinxbfcode{\sphinxupquote{import\_event\_log}}}{\emph{\DUrole{n}{config\_file}}, \emph{\DUrole{n}{storage\_type}\DUrole{o}{=}\DUrole{default_value}{StorageType.COLUMN\_BASED\_AT\_ONCE}}}{}
\sphinxAtStartPar
Import and validate an event log into the internal representation of an EventLogStorage object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{config\_file}} \textendash{} the path to a JSON configuration file

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{storage\_type}} ({\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.event_log.StorageType}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StorageType}}}}}) \textendash{} the storage type of the database where we want to import the log, default StorageType.COLUMN\_BASED\_AT\_ONCE

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
EventLogStorage object

\item[{Return type}] \leavevmode
\sphinxAtStartPar
log

\end{description}\end{quote}

\end{fulllineitems}

\index{import\_xes\_file() (in module event\_log\_analyzer.importer)@\spxentry{import\_xes\_file()}\spxextra{in module event\_log\_analyzer.importer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.importer.import_xes_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{event\_log\_analyzer.importer.}}\sphinxbfcode{\sphinxupquote{import\_xes\_file}}}{\emph{\DUrole{n}{config}}}{}
\sphinxAtStartPar
Import the event log from the file format into a pandas dataframe with timestamps
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{config\_file}} \textendash{} the path to a JSON configuration file

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the pandas dataframe without any modification

\item[{Return type}] \leavevmode
\sphinxAtStartPar
raw\_dataframe

\end{description}\end{quote}

\end{fulllineitems}



\section{event\_log\_analyzer.adapter module}
\label{\detokenize{event_log_analyzer:module-event_log_analyzer.adapter}}\label{\detokenize{event_log_analyzer:event-log-analyzer-adapter-module}}\index{module@\spxentry{module}!event\_log\_analyzer.adapter@\spxentry{event\_log\_analyzer.adapter}}\index{event\_log\_analyzer.adapter@\spxentry{event\_log\_analyzer.adapter}!module@\spxentry{module}}
\sphinxAtStartPar
This module contains all functionality related to the adaption process to transform new event logs in a unified format
\index{ActivityInstanceAdder (class in event\_log\_analyzer.adapter)@\spxentry{ActivityInstanceAdder}\spxextra{class in event\_log\_analyzer.adapter}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.ActivityInstanceAdder}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.}}\sphinxbfcode{\sphinxupquote{ActivityInstanceAdder}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.adapter.Adapter}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.Adapter}}}}}

\sphinxAtStartPar
adds an activity instance, if not already present (only applicable to logs in atomic format with ‘Timestamp’ attribute \sphinxhyphen{}\textgreater{} TimestampRenamer needs to be applied before)
\index{transform() (event\_log\_analyzer.adapter.ActivityInstanceAdder method)@\spxentry{transform()}\spxextra{event\_log\_analyzer.adapter.ActivityInstanceAdder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.ActivityInstanceAdder.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{\DUrole{n}{cfg}}, \emph{\DUrole{n}{df}}}{}
\sphinxAtStartPar
transforms the given dataframe and returns it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cfg}} (\sphinxstyleliteralemphasis{\sphinxupquote{json}}) \textendash{} the configuration file

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}) \textendash{} the event log as a data frame that should be transformed

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns the transformed data frame

\item[{Return type}] \leavevmode
\sphinxAtStartPar
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Adapter (class in event\_log\_analyzer.adapter)@\spxentry{Adapter}\spxextra{class in event\_log\_analyzer.adapter}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.Adapter}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.}}\sphinxbfcode{\sphinxupquote{Adapter}}}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{abc.ABC}}

\sphinxAtStartPar
Adapter interface which every adapter needs to implement
\index{transform() (event\_log\_analyzer.adapter.Adapter method)@\spxentry{transform()}\spxextra{event\_log\_analyzer.adapter.Adapter method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.Adapter.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{transform}}}{\emph{\DUrole{n}{cfg}}, \emph{\DUrole{n}{df}}}{}
\sphinxAtStartPar
transforms the given dataframe and returns it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cfg}} (\sphinxstyleliteralemphasis{\sphinxupquote{json}}) \textendash{} the configuration file

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}) \textendash{} the event log as a data frame that should be transformed

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns the transformed data frame

\item[{Return type}] \leavevmode
\sphinxAtStartPar
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ColumnRenamer (class in event\_log\_analyzer.adapter)@\spxentry{ColumnRenamer}\spxextra{class in event\_log\_analyzer.adapter}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.ColumnRenamer}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.}}\sphinxbfcode{\sphinxupquote{ColumnRenamer}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.adapter.Adapter}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.Adapter}}}}}

\sphinxAtStartPar
maps all attributes names as specified in the config file (this adapter should be applied after all other adapters that need the original attribute names have been applied)
\index{transform() (event\_log\_analyzer.adapter.ColumnRenamer method)@\spxentry{transform()}\spxextra{event\_log\_analyzer.adapter.ColumnRenamer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.ColumnRenamer.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{\DUrole{n}{cfg}}, \emph{\DUrole{n}{df}}}{}
\sphinxAtStartPar
transforms the given dataframe and returns it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cfg}} (\sphinxstyleliteralemphasis{\sphinxupquote{json}}) \textendash{} the configuration file

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}) \textendash{} the event log as a data frame that should be transformed

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns the transformed data frame

\item[{Return type}] \leavevmode
\sphinxAtStartPar
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{EventToIntervalLog (class in event\_log\_analyzer.adapter)@\spxentry{EventToIntervalLog}\spxextra{class in event\_log\_analyzer.adapter}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.EventToIntervalLog}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.}}\sphinxbfcode{\sphinxupquote{EventToIntervalLog}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.adapter.Adapter}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.Adapter}}}}}

\sphinxAtStartPar
if a log is given in atomic format, this adapter converts it to interval event log format (only applicable if log contains ‘Job’, ‘Machine’, ‘Timestamp’ and ‘Transaction\_Type’ attributes)
\index{transform() (event\_log\_analyzer.adapter.EventToIntervalLog method)@\spxentry{transform()}\spxextra{event\_log\_analyzer.adapter.EventToIntervalLog method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.EventToIntervalLog.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{\DUrole{n}{cfg}}, \emph{\DUrole{n}{df}}}{}
\sphinxAtStartPar
transforms the given dataframe and returns it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cfg}} (\sphinxstyleliteralemphasis{\sphinxupquote{json}}) \textendash{} the configuration file

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}) \textendash{} the event log as a data frame that should be transformed

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns the transformed data frame

\item[{Return type}] \leavevmode
\sphinxAtStartPar
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{transform\_without\_pm4py() (event\_log\_analyzer.adapter.EventToIntervalLog method)@\spxentry{transform\_without\_pm4py()}\spxextra{event\_log\_analyzer.adapter.EventToIntervalLog method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.EventToIntervalLog.transform_without_pm4py}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform\_without\_pm4py}}}{\emph{\DUrole{n}{cfg}}, \emph{\DUrole{n}{df}}}{}
\sphinxAtStartPar
this method shows how the transform() method could be implemented without pm4py

\end{fulllineitems}


\end{fulllineitems}

\index{IntervalToEventLogTransformer (class in event\_log\_analyzer.adapter)@\spxentry{IntervalToEventLogTransformer}\spxextra{class in event\_log\_analyzer.adapter}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.IntervalToEventLogTransformer}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.}}\sphinxbfcode{\sphinxupquote{IntervalToEventLogTransformer}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.adapter.Adapter}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.Adapter}}}}}

\sphinxAtStartPar
if a log is given in interval format, this adapter converts it to atomic event log format (two timestamps ‘Start’ and ‘Complete’ are required \sphinxhyphen{}\textgreater{} TimestampRenamer needs to be applied before)
\index{transform() (event\_log\_analyzer.adapter.IntervalToEventLogTransformer method)@\spxentry{transform()}\spxextra{event\_log\_analyzer.adapter.IntervalToEventLogTransformer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.IntervalToEventLogTransformer.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{\DUrole{n}{cfg}}, \emph{\DUrole{n}{df}}}{}
\sphinxAtStartPar
transforms the given dataframe and returns it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cfg}} (\sphinxstyleliteralemphasis{\sphinxupquote{json}}) \textendash{} the configuration file

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}) \textendash{} the event log as a data frame that should be transformed

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns the transformed data frame

\item[{Return type}] \leavevmode
\sphinxAtStartPar
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{RowIDAdder (class in event\_log\_analyzer.adapter)@\spxentry{RowIDAdder}\spxextra{class in event\_log\_analyzer.adapter}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.RowIDAdder}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.}}\sphinxbfcode{\sphinxupquote{RowIDAdder}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.adapter.Adapter}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.Adapter}}}}}

\sphinxAtStartPar
maps a given row id to the Row\_ID attribute, if nothing is specified a new row column id is added to the log
\index{transform() (event\_log\_analyzer.adapter.RowIDAdder method)@\spxentry{transform()}\spxextra{event\_log\_analyzer.adapter.RowIDAdder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.RowIDAdder.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{\DUrole{n}{cfg}}, \emph{\DUrole{n}{df}}}{}
\sphinxAtStartPar
transforms the given dataframe and returns it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cfg}} (\sphinxstyleliteralemphasis{\sphinxupquote{json}}) \textendash{} the configuration file

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}) \textendash{} the event log as a data frame that should be transformed

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns the transformed data frame

\item[{Return type}] \leavevmode
\sphinxAtStartPar
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Sorter (class in event\_log\_analyzer.adapter)@\spxentry{Sorter}\spxextra{class in event\_log\_analyzer.adapter}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.Sorter}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.}}\sphinxbfcode{\sphinxupquote{Sorter}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.adapter.Adapter}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.Adapter}}}}}

\sphinxAtStartPar
sorts the event log if this is not already done by default
\index{transform() (event\_log\_analyzer.adapter.Sorter method)@\spxentry{transform()}\spxextra{event\_log\_analyzer.adapter.Sorter method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.Sorter.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{\DUrole{n}{cfg}}, \emph{\DUrole{n}{df}}}{}
\sphinxAtStartPar
transforms the given dataframe and returns it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cfg}} (\sphinxstyleliteralemphasis{\sphinxupquote{json}}) \textendash{} the configuration file

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}) \textendash{} the event log as a data frame that should be transformed

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns the transformed data frame

\item[{Return type}] \leavevmode
\sphinxAtStartPar
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{TimestampModifier (class in event\_log\_analyzer.adapter)@\spxentry{TimestampModifier}\spxextra{class in event\_log\_analyzer.adapter}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.TimestampModifier}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.}}\sphinxbfcode{\sphinxupquote{TimestampModifier}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.adapter.Adapter}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.Adapter}}}}}

\sphinxAtStartPar
transforms all timestamps, indicated in the config file, to a common format (must be done before timestamps are renamed)
\index{get\_sec() (event\_log\_analyzer.adapter.TimestampModifier method)@\spxentry{get\_sec()}\spxextra{event\_log\_analyzer.adapter.TimestampModifier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.TimestampModifier.get_sec}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_sec}}}{\emph{\DUrole{n}{time\_str}}}{}
\sphinxAtStartPar
converts a timestamp in HH:mm:ss format to seconds
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{time\_str}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} a string in the following format HH:mm:ss, where the hours are continuous, i.e. this timestamp can be considered as duration

\item[{Returns}] \leavevmode
\sphinxAtStartPar
duration in seconds

\item[{Return type}] \leavevmode
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}

\index{transform() (event\_log\_analyzer.adapter.TimestampModifier method)@\spxentry{transform()}\spxextra{event\_log\_analyzer.adapter.TimestampModifier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.TimestampModifier.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{\DUrole{n}{cfg}}, \emph{\DUrole{n}{df}}}{}
\sphinxAtStartPar
transforms the given dataframe and returns it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cfg}} (\sphinxstyleliteralemphasis{\sphinxupquote{json}}) \textendash{} the configuration file

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}) \textendash{} the event log as a data frame that should be transformed

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns the transformed data frame

\item[{Return type}] \leavevmode
\sphinxAtStartPar
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{TimestampRenamer (class in event\_log\_analyzer.adapter)@\spxentry{TimestampRenamer}\spxextra{class in event\_log\_analyzer.adapter}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.TimestampRenamer}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.}}\sphinxbfcode{\sphinxupquote{TimestampRenamer}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.adapter.Adapter}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.adapter.Adapter}}}}}

\sphinxAtStartPar
maps all timestamp attribute names as specified in the config file (in atomic event log, we map them to ‘Timestamp’; in interval log, we map them to ‘Start’ and ‘Complete’ timestamps)
\index{transform() (event\_log\_analyzer.adapter.TimestampRenamer method)@\spxentry{transform()}\spxextra{event\_log\_analyzer.adapter.TimestampRenamer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.adapter.TimestampRenamer.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{\DUrole{n}{cfg}}, \emph{\DUrole{n}{df}}}{}
\sphinxAtStartPar
transforms the given dataframe and returns it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cfg}} (\sphinxstyleliteralemphasis{\sphinxupquote{json}}) \textendash{} the configuration file

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}) \textendash{} the event log as a data frame that should be transformed

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns the transformed data frame

\item[{Return type}] \leavevmode
\sphinxAtStartPar
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{event\_log\_analyzer.event\_log module}
\label{\detokenize{event_log_analyzer:module-event_log_analyzer.event_log}}\label{\detokenize{event_log_analyzer:event-log-analyzer-event-log-module}}\index{module@\spxentry{module}!event\_log\_analyzer.event\_log@\spxentry{event\_log\_analyzer.event\_log}}\index{event\_log\_analyzer.event\_log@\spxentry{event\_log\_analyzer.event\_log}!module@\spxentry{module}}
\sphinxAtStartPar
This module is responsible for storing and managing the event log data.
\index{EventLogStorage (class in event\_log\_analyzer.event\_log)@\spxentry{EventLogStorage}\spxextra{class in event\_log\_analyzer.event\_log}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.event\_log.}}\sphinxbfcode{\sphinxupquote{EventLogStorage}}}{\emph{\DUrole{n}{cfg}}, \emph{\DUrole{n}{storage\_type}\DUrole{o}{=}\DUrole{default_value}{StorageType.ROW\_BASED}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
The EventLogStorage object stores all information about a given event log. To itialize the object, the dataframe that stores the event log already needs to be in a correct format, adaption needs to be done before!
\index{\_con (event\_log\_analyzer.event\_log.EventLogStorage attribute)@\spxentry{\_con}\spxextra{event\_log\_analyzer.event\_log.EventLogStorage attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage._con}}\pysigline{\sphinxbfcode{\sphinxupquote{\_con}}}
\sphinxAtStartPar
the database connection
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxAtStartPar
Connection

\end{description}\end{quote}

\end{fulllineitems}

\index{\_dataframe (event\_log\_analyzer.event\_log.EventLogStorage attribute)@\spxentry{\_dataframe}\spxextra{event\_log\_analyzer.event\_log.EventLogStorage attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage._dataframe}}\pysigline{\sphinxbfcode{\sphinxupquote{\_dataframe}}}
\sphinxAtStartPar
the actual event log data

\end{fulllineitems}

\index{\_config (event\_log\_analyzer.event\_log.EventLogStorage attribute)@\spxentry{\_config}\spxextra{event\_log\_analyzer.event\_log.EventLogStorage attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage._config}}\pysigline{\sphinxbfcode{\sphinxupquote{\_config}}}
\sphinxAtStartPar
the configuration file
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxAtStartPar
json

\end{description}\end{quote}

\end{fulllineitems}

\index{\_storage\_type (event\_log\_analyzer.event\_log.EventLogStorage attribute)@\spxentry{\_storage\_type}\spxextra{event\_log\_analyzer.event\_log.EventLogStorage attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage._storage_type}}\pysigline{\sphinxbfcode{\sphinxupquote{\_storage\_type}}}
\sphinxAtStartPar
specifies the data layout used in the event log storage
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.event_log.StorageType}]{\sphinxcrossref{StorageType}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_new\_dataframe() (event\_log\_analyzer.event\_log.EventLogStorage method)@\spxentry{add\_new\_dataframe()}\spxextra{event\_log\_analyzer.event\_log.EventLogStorage method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage.add_new_dataframe}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_new\_dataframe}}}{\emph{\DUrole{n}{new\_df}}}{}
\sphinxAtStartPar
validates the log and then adds it into the EventLogStorage database and the database is optimized (e.g. by creating indexes)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_log}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}) \textendash{} the event log needs to be in the goal format, i.e. in atomic event log form with one timestamp “Timestamp” in a pandas timestamp format

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_interval\_log() (event\_log\_analyzer.event\_log.EventLogStorage method)@\spxentry{create\_interval\_log()}\spxextra{event\_log\_analyzer.event\_log.EventLogStorage method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage.create_interval_log}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_interval\_log}}}{}{}
\sphinxAtStartPar
if possible construct an interval log out of the stored atomic event log and save it into the database as a separate table

\end{fulllineitems}

\index{get\_event\_log() (event\_log\_analyzer.event\_log.EventLogStorage method)@\spxentry{get\_event\_log()}\spxextra{event\_log\_analyzer.event\_log.EventLogStorage method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage.get_event_log}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_event\_log}}}{}{}
\sphinxAtStartPar
loads the event log from the database
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{dataframe} \textendash{} the whole event log from the data base as a data frame

\item[{Return type}] \leavevmode
\sphinxAtStartPar
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_interval\_log() (event\_log\_analyzer.event\_log.EventLogStorage method)@\spxentry{get\_interval\_log()}\spxextra{event\_log\_analyzer.event\_log.EventLogStorage method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage.get_interval_log}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_interval\_log}}}{}{}
\sphinxAtStartPar
loads the interval log from the database
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{dataframe} \textendash{} the whole interval log from the data base as a data frame

\item[{Return type}] \leavevmode
\sphinxAtStartPar
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_interval\_sequence() (event\_log\_analyzer.event\_log.EventLogStorage method)@\spxentry{get\_interval\_sequence()}\spxextra{event\_log\_analyzer.event\_log.EventLogStorage method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage.get_interval_sequence}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_interval\_sequence}}}{\emph{\DUrole{n}{attr}}, \emph{\DUrole{n}{needed\_columns}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}}{}
\sphinxAtStartPar
groups the interval log database and returns a generator object of the sequence of the given attribute as a generator object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{attr}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the attribute by which the event log should be grouped

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{needed\_columns}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} a list of attributes/columns that need to be accessed, by default {[}{]} (the empty list stands for all attributes)

\end{itemize}

\item[{Yields}] \leavevmode
\sphinxAtStartPar
\sphinxstyleemphasis{pandas.DataFrame} \textendash{} The next interval sequence as a dataframe.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sequence() (event\_log\_analyzer.event\_log.EventLogStorage method)@\spxentry{get\_sequence()}\spxextra{event\_log\_analyzer.event\_log.EventLogStorage method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage.get_sequence}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_sequence}}}{\emph{\DUrole{n}{attr}}, \emph{\DUrole{n}{needed\_columns}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}}{}
\sphinxAtStartPar
groups the event log database and returns a generator object of the sequence of the given attribute as a generator object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{attr}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the attribute by which the event log should be grouped

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{needed\_columns}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} a list of attributes/columns that need to be accessed, by default {[}{]} (the empty list stands for all attributes)

\end{itemize}

\item[{Yields}] \leavevmode
\sphinxAtStartPar
\sphinxstyleemphasis{pandas.DataFrame} \textendash{} The next sequence as a dataframe.

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_event\_log() (event\_log\_analyzer.event\_log.EventLogStorage method)@\spxentry{print\_event\_log()}\spxextra{event\_log\_analyzer.event\_log.EventLogStorage method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage.print_event_log}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{print\_event\_log}}}{}{}
\sphinxAtStartPar
prints the event log on the console

\end{fulllineitems}

\index{save\_adapted\_event\_log() (event\_log\_analyzer.event\_log.EventLogStorage method)@\spxentry{save\_adapted\_event\_log()}\spxextra{event\_log\_analyzer.event\_log.EventLogStorage method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage.save_adapted_event_log}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save\_adapted\_event\_log}}}{\emph{\DUrole{n}{file\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}adapted\_event\_log.csv\textquotesingle{}}}}{}
\sphinxAtStartPar
saves the adapted event log that is internally stored in the database in the given file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} file name where the log should be saved, by default “adapted\_event\_log.csv”

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{StorageType (class in event\_log\_analyzer.event\_log)@\spxentry{StorageType}\spxextra{class in event\_log\_analyzer.event\_log}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.StorageType}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.event\_log.}}\sphinxbfcode{\sphinxupquote{StorageType}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{enum.Enum}}

\sphinxAtStartPar
The storage types specify the data layout that is used internally to store the event logs.
\index{COLUMN\_BASED (event\_log\_analyzer.event\_log.StorageType attribute)@\spxentry{COLUMN\_BASED}\spxextra{event\_log\_analyzer.event\_log.StorageType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.StorageType.COLUMN_BASED}}\pysigline{\sphinxbfcode{\sphinxupquote{COLUMN\_BASED}}\sphinxbfcode{\sphinxupquote{ = 1}}}
\end{fulllineitems}

\index{COLUMN\_BASED\_AT\_ONCE (event\_log\_analyzer.event\_log.StorageType attribute)@\spxentry{COLUMN\_BASED\_AT\_ONCE}\spxextra{event\_log\_analyzer.event\_log.StorageType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.StorageType.COLUMN_BASED_AT_ONCE}}\pysigline{\sphinxbfcode{\sphinxupquote{COLUMN\_BASED\_AT\_ONCE}}\sphinxbfcode{\sphinxupquote{ = 3}}}
\end{fulllineitems}

\index{ROW\_BASED (event\_log\_analyzer.event\_log.StorageType attribute)@\spxentry{ROW\_BASED}\spxextra{event\_log\_analyzer.event\_log.StorageType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.event_log.StorageType.ROW_BASED}}\pysigline{\sphinxbfcode{\sphinxupquote{ROW\_BASED}}\sphinxbfcode{\sphinxupquote{ = 2}}}
\end{fulllineitems}


\end{fulllineitems}



\section{event\_log\_analyzer.validate module}
\label{\detokenize{event_log_analyzer:module-event_log_analyzer.validate}}\label{\detokenize{event_log_analyzer:event-log-analyzer-validate-module}}\index{module@\spxentry{module}!event\_log\_analyzer.validate@\spxentry{event\_log\_analyzer.validate}}\index{event\_log\_analyzer.validate@\spxentry{event\_log\_analyzer.validate}!module@\spxentry{module}}
\sphinxAtStartPar
This module is responsible for validating event logs before storing them in the database as well validating the config files.
\index{validate() (in module event\_log\_analyzer.validate)@\spxentry{validate()}\spxextra{in module event\_log\_analyzer.validate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.validate.validate}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{event\_log\_analyzer.validate.}}\sphinxbfcode{\sphinxupquote{validate}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
checks whether the log is sorted by the timestamp column
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{event\_log}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}) \textendash{} the dataframe of the event log in atomic event log format (‘Timestamp’ column required)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Raises}} \textendash{} \begin{description}
\item[{ValueError}] \leavevmode
\sphinxAtStartPar
if the timestamps are incorrect, i.e. no timestamp column is present or if the log is not sorted by this timestamp

\end{description}


\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{validate\_config() (in module event\_log\_analyzer.validate)@\spxentry{validate\_config()}\spxextra{in module event\_log\_analyzer.validate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.validate.validate_config}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{event\_log\_analyzer.validate.}}\sphinxbfcode{\sphinxupquote{validate\_config}}}{\emph{\DUrole{n}{json\_schema\_path}}, \emph{\DUrole{n}{config\_file}}}{}
\sphinxAtStartPar
validates the given config\_file, whether it is valid according to the given schema
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{json\_schema}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the path to the JSON schema, where the config file format has been specified

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{config\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} the JSON object that was parsed

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError if the config file is invalid}} \textendash{} 

\end{description}\end{quote}

\end{fulllineitems}



\section{event\_log\_analyzer.pattern\_library package}
\label{\detokenize{event_log_analyzer:event-log-analyzer-pattern-library-package}}

\subsection{event\_log\_analyzer.pattern\_library.pattern module}
\label{\detokenize{event_log_analyzer:module-event_log_analyzer.pattern_library.pattern}}\label{\detokenize{event_log_analyzer:event-log-analyzer-pattern-library-pattern-module}}\index{module@\spxentry{module}!event\_log\_analyzer.pattern\_library.pattern@\spxentry{event\_log\_analyzer.pattern\_library.pattern}}\index{event\_log\_analyzer.pattern\_library.pattern@\spxentry{event\_log\_analyzer.pattern\_library.pattern}!module@\spxentry{module}}
\sphinxAtStartPar
This module implements contains the abstract pattern class that must be extended by any pattern.
\index{Pattern (class in event\_log\_analyzer.pattern\_library.pattern)@\spxentry{Pattern}\spxextra{class in event\_log\_analyzer.pattern\_library.pattern}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.pattern.}}\sphinxbfcode{\sphinxupquote{Pattern}}}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{abc.ABC}}

\sphinxAtStartPar
The abstract Pattern class describes single constraint patterns with all its dependencies.
\index{name (event\_log\_analyzer.pattern\_library.pattern.Pattern attribute)@\spxentry{name}\spxextra{event\_log\_analyzer.pattern\_library.pattern.Pattern attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}}
\sphinxAtStartPar
a unique name, with which each pattern can be identified
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{dependencies (event\_log\_analyzer.pattern\_library.pattern.Pattern attribute)@\spxentry{dependencies}\spxextra{event\_log\_analyzer.pattern\_library.pattern.Pattern attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern.dependencies}}\pysigline{\sphinxbfcode{\sphinxupquote{dependencies}}}
\sphinxAtStartPar
dependencies to other patterns (identified by their name) given as a key value pair where the key stands for the type of dependency (for example necessary conditions)
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxAtStartPar
Dict{[}str, List{[}str{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{applies (event\_log\_analyzer.pattern\_library.pattern.Pattern attribute)@\spxentry{applies}\spxextra{event\_log\_analyzer.pattern\_library.pattern.Pattern attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern.applies}}\pysigline{\sphinxbfcode{\sphinxupquote{applies}}}
\sphinxAtStartPar
True if the pattern applies, False if not, None if it has not been checked yet
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_dependencies() (event\_log\_analyzer.pattern\_library.pattern.Pattern method)@\spxentry{add\_dependencies()}\spxextra{event\_log\_analyzer.pattern\_library.pattern.Pattern method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern.add_dependencies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_dependencies}}}{\emph{\DUrole{n}{pattern\_structure}}}{}
\sphinxAtStartPar
adds all dependencies to other patterns in the pattern structure
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pattern\_structure}} ({\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern_structure.PatternStructure}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PatternStructure}}}}}) \textendash{} the Pattern Structure object in which the dependencies should be linked

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_dependencies() (event\_log\_analyzer.pattern\_library.pattern.Pattern method)@\spxentry{check\_dependencies()}\spxextra{event\_log\_analyzer.pattern\_library.pattern.Pattern method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern.check_dependencies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_dependencies}}}{}{}
\sphinxAtStartPar
checks whether the pattern already applies without further checking based on dependencies with other classes and logs it
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if the pattern already applies without further checking, False if it cannot apply anymore, or otherwise None if no statement can be made

\item[{Return type}] \leavevmode
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{dependencies (event\_log\_analyzer.pattern\_library.pattern.Pattern property)@\spxentry{dependencies}\spxextra{event\_log\_analyzer.pattern\_library.pattern.Pattern property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:id0}}\pysigline{\sphinxbfcode{\sphinxupquote{abstract property }}\sphinxbfcode{\sphinxupquote{dependencies}}}
\end{fulllineitems}

\index{name (event\_log\_analyzer.pattern\_library.pattern.Pattern property)@\spxentry{name}\spxextra{event\_log\_analyzer.pattern\_library.pattern.Pattern property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:id1}}\pysigline{\sphinxbfcode{\sphinxupquote{abstract property }}\sphinxbfcode{\sphinxupquote{name}}}
\end{fulllineitems}

\index{pattern\_applies() (event\_log\_analyzer.pattern\_library.pattern.Pattern method)@\spxentry{pattern\_applies()}\spxextra{event\_log\_analyzer.pattern\_library.pattern.Pattern method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern.pattern_applies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{pattern\_applies}}}{\emph{\DUrole{n}{event\_log}}}{{ $\rightarrow$ bool}}
\sphinxAtStartPar
checks whether the pattern applies
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{event\_log}} ({\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{EventLogStorage}}}}}) \textendash{} the EventLogStorage object of the log on which the conditions of the pattern should be checked

\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if the pattern applies, False if it does not apply

\item[{Return type}] \leavevmode
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_name() (event\_log\_analyzer.pattern\_library.pattern.Pattern method)@\spxentry{print\_name()}\spxextra{event\_log\_analyzer.pattern\_library.pattern.Pattern method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern.print_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{print\_name}}}{}{}
\sphinxAtStartPar
prints the unique name

\end{fulllineitems}


\end{fulllineitems}



\subsection{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_pattern module}
\label{\detokenize{event_log_analyzer:event-log-analyzer-pattern-library-manufacturing-scheduling-pattern-module}}\phantomsection\label{\detokenize{event_log_analyzer:module-event_log_analyzer.pattern_library.manufacturing_scheduling_patterns}}\index{module@\spxentry{module}!event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns@\spxentry{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns}}\index{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns@\spxentry{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns}!module@\spxentry{module}}
\sphinxAtStartPar
This module contains all patterns, that have the Manufacturing Scheduling Pattern as a prerequisite
\index{DistinguishableResource (class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns)@\spxentry{DistinguishableResource}\spxextra{class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.DistinguishableResource}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.}}\sphinxbfcode{\sphinxupquote{DistinguishableResource}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.pattern.Pattern}}}}}

\sphinxAtStartPar
In the Distinguishable Resource Pattern, when processing a number of operations, exactly one resource from a set of distinguishable resources needs to be present for each of the operations.

\sphinxAtStartPar
Currently the pattern only checks one resource (in the ‘Resource’ column), when having several resources, they need to be manufally checked one by one
\index{dependencies (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.DistinguishableResource attribute)@\spxentry{dependencies}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.DistinguishableResource attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.DistinguishableResource.dependencies}}\pysigline{\sphinxbfcode{\sphinxupquote{dependencies}}\sphinxbfcode{\sphinxupquote{ = \{\textquotesingle{}forces\textquotesingle{}: {[}{]}, \textquotesingle{}requires\textquotesingle{}: {[}\textquotesingle{}Manufacturing\_Scheduling\_Pattern\textquotesingle{}{]}\}}}}
\end{fulllineitems}

\index{name (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.DistinguishableResource attribute)@\spxentry{name}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.DistinguishableResource attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.DistinguishableResource.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}Distinguishable\_Resource\_Pattern\textquotesingle{}}}}
\end{fulllineitems}

\index{pattern\_applies() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.DistinguishableResource method)@\spxentry{pattern\_applies()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.DistinguishableResource method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.DistinguishableResource.pattern_applies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pattern\_applies}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
one resource from a set of distinguishable resources must be present at every operation, but only one operation can be processed per resource
(checking on atomic event log)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{event\_log}} ({\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{EventLogStorage}}}}}) \textendash{} the EventLogStorage object of the log on which the conditions of the pattern should be checked

\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if the pattern applies, False if it does not apply

\item[{Return type}] \leavevmode
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{FlowShop (class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns)@\spxentry{FlowShop}\spxextra{class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.FlowShop}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.}}\sphinxbfcode{\sphinxupquote{FlowShop}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.pattern.Pattern}}}}}

\sphinxAtStartPar
In the Flow Shop Pattern, each job needs to be processed on each of the machines in a predetermined order and the order is the same for all jobs.
\index{cond\_a() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.FlowShop method)@\spxentry{cond\_a()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.FlowShop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.FlowShop.cond_a}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cond\_a}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
every job can be processed on every machine at most once

\end{fulllineitems}

\index{cond\_b() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.FlowShop method)@\spxentry{cond\_b()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.FlowShop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.FlowShop.cond_b}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cond\_b}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
every job consists of exactly as much operations as machines exist in total

\end{fulllineitems}

\index{cond\_c() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.FlowShop method)@\spxentry{cond\_c()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.FlowShop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.FlowShop.cond_c}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cond\_c}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
the route of every job through the machines must be the same

\end{fulllineitems}

\index{dependencies (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.FlowShop attribute)@\spxentry{dependencies}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.FlowShop attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.FlowShop.dependencies}}\pysigline{\sphinxbfcode{\sphinxupquote{dependencies}}\sphinxbfcode{\sphinxupquote{ = \{\textquotesingle{}forces\textquotesingle{}: {[}{]}, \textquotesingle{}requires\textquotesingle{}: {[}\textquotesingle{}Job\_Shop\_Pattern\textquotesingle{}{]}\}}}}
\end{fulllineitems}

\index{name (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.FlowShop attribute)@\spxentry{name}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.FlowShop attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.FlowShop.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}Flow\_Shop\_Pattern\textquotesingle{}}}}
\end{fulllineitems}

\index{pattern\_applies() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.FlowShop method)@\spxentry{pattern\_applies()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.FlowShop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.FlowShop.pattern_applies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pattern\_applies}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
the pattern applies if all three conditions (a), (b) and (c) apply
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{event\_log}} ({\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{EventLogStorage}}}}}) \textendash{} the EventLogStorage object of the log on which the conditions of the pattern should be checked

\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if the pattern applies, False if it does not apply

\item[{Return type}] \leavevmode
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{IndistinguishableResource (class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns)@\spxentry{IndistinguishableResource}\spxextra{class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.IndistinguishableResource}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.}}\sphinxbfcode{\sphinxupquote{IndistinguishableResource}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.pattern.Pattern}}}}}

\sphinxAtStartPar
In the Indistinguishable Resource Pattern, when processing a number of operations, exactly one resource from a set of indistinguishable resources needs to be present for each operation.

\sphinxAtStartPar
Currently the pattern only checks one resource (in the ‘Resource’ column), when having several resources, they need to be manufally checked one by one
\index{dependencies (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.IndistinguishableResource attribute)@\spxentry{dependencies}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.IndistinguishableResource attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.IndistinguishableResource.dependencies}}\pysigline{\sphinxbfcode{\sphinxupquote{dependencies}}\sphinxbfcode{\sphinxupquote{ = \{\textquotesingle{}forces\textquotesingle{}: {[}{]}, \textquotesingle{}requires\textquotesingle{}: {[}\textquotesingle{}Manufacturing\_Scheduling\_Pattern\textquotesingle{}{]}\}}}}
\end{fulllineitems}

\index{name (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.IndistinguishableResource attribute)@\spxentry{name}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.IndistinguishableResource attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.IndistinguishableResource.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}Indistinguishable\_Resource\_Pattern\textquotesingle{}}}}
\end{fulllineitems}

\index{pattern\_applies() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.IndistinguishableResource method)@\spxentry{pattern\_applies()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.IndistinguishableResource method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.IndistinguishableResource.pattern_applies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pattern\_applies}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
for each operation there must be exactly one resource from a set of indistinguishable resources
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{event\_log}} ({\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{EventLogStorage}}}}}) \textendash{} the EventLogStorage object of the log on which the conditions of the pattern should be checked

\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if the pattern applies, False if it does not apply

\item[{Return type}] \leavevmode
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{JobShop (class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns)@\spxentry{JobShop}\spxextra{class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.JobShop}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.}}\sphinxbfcode{\sphinxupquote{JobShop}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.pattern.Pattern}}}}}

\sphinxAtStartPar
In the Job Shop Pattern, each job needs to be processed on a subset of the machines in a predetermined order which might be different between the jobs.
\index{cond\_a() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.JobShop method)@\spxentry{cond\_a()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.JobShop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.JobShop.cond_a}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cond\_a}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
jobs cannot be processed without a machine

\sphinxAtStartPar
vectorization is used on the whole event log to check whether there exists an event without a machine

\end{fulllineitems}

\index{cond\_b() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.JobShop method)@\spxentry{cond\_b()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.JobShop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.JobShop.cond_b}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cond\_b}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
no two operations of the same job can be processed at the same time

\sphinxAtStartPar
the condition is checked on the atomic event log

\end{fulllineitems}

\index{cond\_b\_interval() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.JobShop method)@\spxentry{cond\_b\_interval()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.JobShop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.JobShop.cond_b_interval}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cond\_b\_interval}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
no two operations of the same job can be processed at the same time

\sphinxAtStartPar
the condition is checked on the interval log

\end{fulllineitems}

\index{cond\_c() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.JobShop method)@\spxentry{cond\_c()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.JobShop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.JobShop.cond_c}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cond\_c}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
No machine can process more than one operation at the same time

\sphinxAtStartPar
the condition is checked on the atomic event log

\end{fulllineitems}

\index{cond\_c\_interval() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.JobShop method)@\spxentry{cond\_c\_interval()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.JobShop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.JobShop.cond_c_interval}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cond\_c\_interval}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
No machine can process more than one operation at the same time

\sphinxAtStartPar
the condition is checked on the interval log

\end{fulllineitems}

\index{dependencies (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.JobShop attribute)@\spxentry{dependencies}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.JobShop attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.JobShop.dependencies}}\pysigline{\sphinxbfcode{\sphinxupquote{dependencies}}\sphinxbfcode{\sphinxupquote{ = \{\textquotesingle{}forces\textquotesingle{}: {[}{]}, \textquotesingle{}requires\textquotesingle{}: {[}\textquotesingle{}Manufacturing\_Scheduling\_Pattern\textquotesingle{}{]}\}}}}
\end{fulllineitems}

\index{name (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.JobShop attribute)@\spxentry{name}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.JobShop attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.JobShop.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}Job\_Shop\_Pattern\textquotesingle{}}}}
\end{fulllineitems}

\index{pattern\_applies() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.JobShop method)@\spxentry{pattern\_applies()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.JobShop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.JobShop.pattern_applies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pattern\_applies}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
the pattern applies if all three conditions (a), (b) and (c) apply
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{event\_log}} ({\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{EventLogStorage}}}}}) \textendash{} the EventLogStorage object of the log on which the conditions of the pattern should be checked

\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if the pattern applies, False if it does not apply

\item[{Return type}] \leavevmode
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ManufacturingScheduling (class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns)@\spxentry{ManufacturingScheduling}\spxextra{class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.ManufacturingScheduling}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.}}\sphinxbfcode{\sphinxupquote{ManufacturingScheduling}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.pattern.Pattern}}}}}

\sphinxAtStartPar
This Pattern sets the basis for all further Scheduling patterns, it has to be checked before the other patterns can be checked to ensure that the pattern contains all needed information.
\index{dependencies (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.ManufacturingScheduling attribute)@\spxentry{dependencies}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.ManufacturingScheduling attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.ManufacturingScheduling.dependencies}}\pysigline{\sphinxbfcode{\sphinxupquote{dependencies}}\sphinxbfcode{\sphinxupquote{ = \{\textquotesingle{}forces\textquotesingle{}: {[}{]}, \textquotesingle{}requires\textquotesingle{}: {[}{]}\}}}}
\end{fulllineitems}

\index{name (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.ManufacturingScheduling attribute)@\spxentry{name}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.ManufacturingScheduling attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.ManufacturingScheduling.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}Manufacturing\_Scheduling\_Pattern\textquotesingle{}}}}
\end{fulllineitems}

\index{pattern\_applies() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.ManufacturingScheduling method)@\spxentry{pattern\_applies()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.ManufacturingScheduling method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.ManufacturingScheduling.pattern_applies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pattern\_applies}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
the pattern applies if all needed attributes are available (Job, Machine, Transaction\_Type) and if the transaction\_types represent intervals,
if the pattern applies we create an interval log which is better suited for checking the further pattern conditions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{event\_log}} ({\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{EventLogStorage}}}}}) \textendash{} the EventLogStorage object of the log on which the conditions of the pattern should be checked

\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if the pattern applies, False if it does not apply

\item[{Return type}] \leavevmode
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{NoWait (class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns)@\spxentry{NoWait}\spxextra{class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.NoWait}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.}}\sphinxbfcode{\sphinxupquote{NoWait}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.pattern.Pattern}}}}}

\sphinxAtStartPar
In the No Wait Pattern, when a number of jobs are to be processed on a set of machines, jobs are not allowed to wait between operations.
\index{dependencies (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.NoWait attribute)@\spxentry{dependencies}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.NoWait attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.NoWait.dependencies}}\pysigline{\sphinxbfcode{\sphinxupquote{dependencies}}\sphinxbfcode{\sphinxupquote{ = \{\textquotesingle{}forces\textquotesingle{}: {[}{]}, \textquotesingle{}requires\textquotesingle{}: {[}\textquotesingle{}Flow\_Shop\_Pattern\textquotesingle{}{]}\}}}}
\end{fulllineitems}

\index{name (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.NoWait attribute)@\spxentry{name}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.NoWait attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.NoWait.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}No\_Wait\_Pattern\textquotesingle{}}}}
\end{fulllineitems}

\index{pattern\_applies() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.NoWait method)@\spxentry{pattern\_applies()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.NoWait method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.NoWait.pattern_applies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pattern\_applies}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
jobs are not allowed to wait between operations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{event\_log}} ({\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{EventLogStorage}}}}}) \textendash{} the EventLogStorage object of the log on which the conditions of the pattern should be checked

\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if the pattern applies, False if it does not apply

\item[{Return type}] \leavevmode
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{OneBlocking (class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns)@\spxentry{OneBlocking}\spxextra{class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.OneBlocking}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.}}\sphinxbfcode{\sphinxupquote{OneBlocking}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.pattern.Pattern}}}}}

\sphinxAtStartPar
In the 1\sphinxhyphen{}Blocking Pattern, when processing a number of jobs on machines under the Flow Shop pattern, there must at any time be at most one job queuing in front of a machine, so the buffer between any two machines has capacity 1.
\index{dependencies (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.OneBlocking attribute)@\spxentry{dependencies}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.OneBlocking attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.OneBlocking.dependencies}}\pysigline{\sphinxbfcode{\sphinxupquote{dependencies}}\sphinxbfcode{\sphinxupquote{ = \{\textquotesingle{}forces\textquotesingle{}: {[}{]}, \textquotesingle{}requires\textquotesingle{}: {[}\textquotesingle{}Permutation\_Pattern\textquotesingle{}{]}\}}}}
\end{fulllineitems}

\index{name (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.OneBlocking attribute)@\spxentry{name}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.OneBlocking attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.OneBlocking.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}1\sphinxhyphen{}blocking\_Pattern\textquotesingle{}}}}
\end{fulllineitems}

\index{pattern\_applies() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.OneBlocking method)@\spxentry{pattern\_applies()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.OneBlocking method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.OneBlocking.pattern_applies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pattern\_applies}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
at any time there cannot be more than one job queing in front of a machine

\sphinxAtStartPar
Note: The pattern is not implemented yet, therefore the pattern never applies!!!
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{event\_log}} ({\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{EventLogStorage}}}}}) \textendash{} the EventLogStorage object of the log on which the conditions of the pattern should be checked

\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if the pattern applies, False if it does not apply

\item[{Return type}] \leavevmode
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Permutation (class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns)@\spxentry{Permutation}\spxextra{class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.Permutation}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.}}\sphinxbfcode{\sphinxupquote{Permutation}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.pattern.Pattern}}}}}

\sphinxAtStartPar
In the Permutation Pattern, when processing a number of jobs on machines under the Flow Shop Pattern no job is allowed to overtake another job, so the order in which jobs are processed on a machine is the same for all machines.
\index{dependencies (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.Permutation attribute)@\spxentry{dependencies}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.Permutation attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.Permutation.dependencies}}\pysigline{\sphinxbfcode{\sphinxupquote{dependencies}}\sphinxbfcode{\sphinxupquote{ = \{\textquotesingle{}forces\textquotesingle{}: {[}{]}, \textquotesingle{}requires\textquotesingle{}: {[}\textquotesingle{}Flow\_Shop\_Pattern\textquotesingle{}{]}\}}}}
\end{fulllineitems}

\index{name (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.Permutation attribute)@\spxentry{name}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.Permutation attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.Permutation.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}Permutation\_Pattern\textquotesingle{}}}}
\end{fulllineitems}

\index{pattern\_applies() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.Permutation method)@\spxentry{pattern\_applies()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.Permutation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.Permutation.pattern_applies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pattern\_applies}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
check whether the Permutation Pattern applies, i.e. jobs cannot overtake each other, all machines process the jobs in the same order
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{event\_log}} ({\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{EventLogStorage}}}}}) \textendash{} the EventLogStorage object of the log on which the conditions of the pattern should be checked

\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if the pattern applies, False if it does not apply

\item[{Return type}] \leavevmode
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ResourceSetupTimes (class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns)@\spxentry{ResourceSetupTimes}\spxextra{class in event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.ResourceSetupTimes}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.}}\sphinxbfcode{\sphinxupquote{ResourceSetupTimes}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.pattern.Pattern}}}}}

\sphinxAtStartPar
In the Resource Setup Times Pattern, a number of operations are to be processed by some distinguishable resources (Distinguishable Resources Pattern needs to apply) and each resource needs a certain amount of time between two operations, where the time depends on the type of the two tasks.

\sphinxAtStartPar
Note: The pattern is not implemented yet, therefore the pattern never applies!!!
\index{dependencies (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.ResourceSetupTimes attribute)@\spxentry{dependencies}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.ResourceSetupTimes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.ResourceSetupTimes.dependencies}}\pysigline{\sphinxbfcode{\sphinxupquote{dependencies}}\sphinxbfcode{\sphinxupquote{ = \{\textquotesingle{}forces\textquotesingle{}: {[}{]}, \textquotesingle{}requires\textquotesingle{}: {[}\textquotesingle{}Distinguishable\_Resource\_Pattern\textquotesingle{}{]}\}}}}
\end{fulllineitems}

\index{name (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.ResourceSetupTimes attribute)@\spxentry{name}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.ResourceSetupTimes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.ResourceSetupTimes.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}Resource\_Setup\_Times\_Pattern\textquotesingle{}}}}
\end{fulllineitems}

\index{pattern\_applies() (event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.ResourceSetupTimes method)@\spxentry{pattern\_applies()}\spxextra{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns.ResourceSetupTimes method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.manufacturing_scheduling_patterns.ResourceSetupTimes.pattern_applies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pattern\_applies}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
each resource needs a certain amount of time between two operations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{event\_log}} ({\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{EventLogStorage}}}}}) \textendash{} the EventLogStorage object of the log on which the conditions of the pattern should be checked

\item[{Returns}] \leavevmode
\sphinxAtStartPar
True if the pattern applies, False if it does not apply

\item[{Return type}] \leavevmode
\sphinxAtStartPar
bool

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{event\_log\_analyzer.pattern\_library.pattern\_structure module}
\label{\detokenize{event_log_analyzer:event-log-analyzer-pattern-library-pattern-structure-module}}\phantomsection\label{\detokenize{event_log_analyzer:module-event_log_analyzer.pattern_library.pattern_structure}}\index{module@\spxentry{module}!event\_log\_analyzer.pattern\_library.pattern\_structure@\spxentry{event\_log\_analyzer.pattern\_library.pattern\_structure}}\index{event\_log\_analyzer.pattern\_library.pattern\_structure@\spxentry{event\_log\_analyzer.pattern\_library.pattern\_structure}!module@\spxentry{module}}
\sphinxAtStartPar
This module contains the functionality that organizes the pattern checking process by structuring them in a graph
\index{PatternStructure (class in event\_log\_analyzer.pattern\_library.pattern\_structure)@\spxentry{PatternStructure}\spxextra{class in event\_log\_analyzer.pattern\_library.pattern\_structure}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern_structure.PatternStructure}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{event\_log\_analyzer.pattern\_library.pattern\_structure.}}\sphinxbfcode{\sphinxupquote{PatternStructure}}}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
A PatternStructure object contains all patterns in a structured way (an aycyclic directed graph), so that the event log can be checked efficiently pattern by pattern.
\index{dependency\_graph (event\_log\_analyzer.pattern\_library.pattern\_structure.PatternStructure attribute)@\spxentry{dependency\_graph}\spxextra{event\_log\_analyzer.pattern\_library.pattern\_structure.PatternStructure attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern_structure.PatternStructure.dependency_graph}}\pysigline{\sphinxbfcode{\sphinxupquote{dependency\_graph}}}
\sphinxAtStartPar
a networkx directed graph object in which the pattern objects are stored
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxAtStartPar
networkx.DiGraph

\end{description}\end{quote}

\end{fulllineitems}

\index{topological\_order (event\_log\_analyzer.pattern\_library.pattern\_structure.PatternStructure attribute)@\spxentry{topological\_order}\spxextra{event\_log\_analyzer.pattern\_library.pattern\_structure.PatternStructure attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern_structure.PatternStructure.topological_order}}\pysigline{\sphinxbfcode{\sphinxupquote{topological\_order}}}
\sphinxAtStartPar
a list of all patterns in a topological order
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxAtStartPar
List{[}{\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern}]{\sphinxcrossref{Pattern}}}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{applying\_pattern\_list() (event\_log\_analyzer.pattern\_library.pattern\_structure.PatternStructure method)@\spxentry{applying\_pattern\_list()}\spxextra{event\_log\_analyzer.pattern\_library.pattern\_structure.PatternStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern_structure.PatternStructure.applying_pattern_list}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{applying\_pattern\_list}}}{}{}
\sphinxAtStartPar
returns a list of all patterns that apply
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{pattern\_list} \textendash{} list of all patterns that apply

\item[{Return type}] \leavevmode
\sphinxAtStartPar
List{[}{\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern.Pattern}]{\sphinxcrossref{Pattern}}}{]}

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} If the patterns have not been checked yet.

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_all\_patterns() (event\_log\_analyzer.pattern\_library.pattern\_structure.PatternStructure method)@\spxentry{check\_all\_patterns()}\spxextra{event\_log\_analyzer.pattern\_library.pattern\_structure.PatternStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern_structure.PatternStructure.check_all_patterns}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_all\_patterns}}}{\emph{\DUrole{n}{event\_log}}}{}
\sphinxAtStartPar
check all patterns that are initialized in the pattern structure in a topological order and log whether they apply
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{log}} ({\hyperref[\detokenize{event_log_analyzer:event_log_analyzer.event_log.EventLogStorage}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{EventLogStorage}}}}}) \textendash{} the event log on which the patterns should be classified

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_pattern\_structure() (event\_log\_analyzer.pattern\_library.pattern\_structure.PatternStructure method)@\spxentry{plot\_pattern\_structure()}\spxextra{event\_log\_analyzer.pattern\_library.pattern\_structure.PatternStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern_structure.PatternStructure.plot_pattern_structure}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_pattern\_structure}}}{\emph{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}pattern\_structure.pdf\textquotesingle{}}}}{}
\sphinxAtStartPar
plots the pattern structure in the given file as a matplotlib figure
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The file name of the output where the graphic should be plotted (default is pattern\_structure.pdf)

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_topological\_ordering() (event\_log\_analyzer.pattern\_library.pattern\_structure.PatternStructure method)@\spxentry{print\_topological\_ordering()}\spxextra{event\_log\_analyzer.pattern\_library.pattern\_structure.PatternStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern_structure.PatternStructure.print_topological_ordering}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{print\_topological\_ordering}}}{}{}
\sphinxAtStartPar
prints the topological order in a list object

\end{fulllineitems}

\index{topological\_ordering() (event\_log\_analyzer.pattern\_library.pattern\_structure.PatternStructure method)@\spxentry{topological\_ordering()}\spxextra{event\_log\_analyzer.pattern\_library.pattern\_structure.PatternStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.pattern_library.pattern_structure.PatternStructure.topological_ordering}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{topological\_ordering}}}{}{}
\sphinxAtStartPar
finds the topological ordering of the initialized pattern structure and stores it in the topological\_order attribute

\end{fulllineitems}


\end{fulllineitems}



\section{event\_log\_analyzer.utils module}
\label{\detokenize{event_log_analyzer:module-event_log_analyzer.utils}}\label{\detokenize{event_log_analyzer:event-log-analyzer-utils-module}}\index{module@\spxentry{module}!event\_log\_analyzer.utils@\spxentry{event\_log\_analyzer.utils}}\index{event\_log\_analyzer.utils@\spxentry{event\_log\_analyzer.utils}!module@\spxentry{module}}
\sphinxAtStartPar
This module contains various functions that are needed in our tool, e.g. initialization of logging.
\index{log\_time() (in module event\_log\_analyzer.utils)@\spxentry{log\_time()}\spxextra{in module event\_log\_analyzer.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{event_log_analyzer:event_log_analyzer.utils.log_time}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{event\_log\_analyzer.utils.}}\sphinxbfcode{\sphinxupquote{log\_time}}}{\emph{\DUrole{n}{logger}}, \emph{\DUrole{n}{text}}}{}
\sphinxAtStartPar
this function can be used as a decorator, which writes the time needed for the decorated function together with a text to the specified logger
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{logger}} (\sphinxstyleliteralemphasis{\sphinxupquote{Logger}}) \textendash{} the logger in which we want to write the information

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{text}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} a text printed together with the time in seconds that the decorated method took to execute

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{e}
\item\relax\sphinxstyleindexentry{event\_log\_analyzer.adapter}\sphinxstyleindexpageref{event_log_analyzer:\detokenize{module-event_log_analyzer.adapter}}
\item\relax\sphinxstyleindexentry{event\_log\_analyzer.event\_log}\sphinxstyleindexpageref{event_log_analyzer:\detokenize{module-event_log_analyzer.event_log}}
\item\relax\sphinxstyleindexentry{event\_log\_analyzer.importer}\sphinxstyleindexpageref{event_log_analyzer:\detokenize{module-event_log_analyzer.importer}}
\item\relax\sphinxstyleindexentry{event\_log\_analyzer.pattern\_library.manufacturing\_scheduling\_patterns}\sphinxstyleindexpageref{event_log_analyzer:\detokenize{module-event_log_analyzer.pattern_library.manufacturing_scheduling_patterns}}
\item\relax\sphinxstyleindexentry{event\_log\_analyzer.pattern\_library.pattern}\sphinxstyleindexpageref{event_log_analyzer:\detokenize{module-event_log_analyzer.pattern_library.pattern}}
\item\relax\sphinxstyleindexentry{event\_log\_analyzer.pattern\_library.pattern\_structure}\sphinxstyleindexpageref{event_log_analyzer:\detokenize{module-event_log_analyzer.pattern_library.pattern_structure}}
\item\relax\sphinxstyleindexentry{event\_log\_analyzer.utils}\sphinxstyleindexpageref{event_log_analyzer:\detokenize{module-event_log_analyzer.utils}}
\item\relax\sphinxstyleindexentry{event\_log\_analyzer.validate}\sphinxstyleindexpageref{event_log_analyzer:\detokenize{module-event_log_analyzer.validate}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}